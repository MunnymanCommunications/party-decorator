
import { GoogleGenAI, Modality } from "@google/genai";
import { parseDataUrl } from '../utils/fileUtils';
import type { Source, ShoppingListItem } from '../types';

if (!process.env.API_KEY) {
    throw new Error("API_KEY environment variable is not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const editImage = async (base64Image: string, prompt: string): Promise<string> => {
    const { mimeType, data } = parseDataUrl(base64Image);

    // Add instruction to avoid generating people
    const fullPrompt = `${prompt}. Do not add any people or human figures to the image.`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
            parts: [
                {
                    inlineData: {
                        data,
                        mimeType,
                    },
                },
                {
                    text: fullPrompt,
                },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE],
        },
    });

    const imagePart = response.candidates?.[0]?.content?.parts?.[0];
    if (imagePart?.inlineData) {
        return `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
    }

    throw new Error('No image was generated by the API.');
};


// Step 1: Generate a simple list of items from the image.
export const generateShoppingListItems = async (
    base64OriginalImage: string,
    base64GeneratedImage: string,
): Promise<string> => {
    const originalImageParts = parseDataUrl(base64OriginalImage);
    const generatedImageParts = parseDataUrl(base64GeneratedImage);
    
    const generationPrompt = "Compare the 'before' and 'after' images. Create a simple bulleted list of only the new decoration items that were added to the 'before' image to create the 'after' image. Do not include items that were already present in the original room. Only list the new item names, without descriptions or links.";
    
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: {
            parts: [
                { text: "This is the 'before' image of the room:" },
                {
                    inlineData: {
                        data: originalImageParts.data,
                        mimeType: originalImageParts.mimeType,
                    },
                },
                { text: "This is the 'after' image, with party decorations added:"},
                {
                    inlineData: {
                        data: generatedImageParts.data,
                        mimeType: generatedImageParts.mimeType,
                    },
                },
                {
                    text: generationPrompt,
                }
            ],
        },
    });

    const list = response.text;
    if (!list) {
        throw new Error('Could not generate a shopping list.');
    }

    return list;
};

// Step 2: Find Amazon links for the items in the list.
export const findProductLinks = async (itemList: string, themePrompt: string): Promise<{ links: ShoppingListItem[]; sources: Source[] }> => {
    const themeContext = themePrompt ? ` The user has specified a theme for the party: "${themePrompt}".` : '';

    const generationPrompt = `For each item in the following shopping list, find a relevant product link exclusively from Amazon.com. The final URL must contain "amazon.com".${themeContext} When searching for products, you MUST incorporate the theme into the search query to find theme-specific items. For example, if the item is "balloons" and the theme is "Halloween", you should search for "Halloween balloons on Amazon".

Format the output as a list where each line contains only the item name, a pipe character (|), and then the full URL. Do not include any extra text, titles, or markdown formatting. The URL provided MUST be a valid Amazon.com product link.

SHOPPING LIST:
${itemList}`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: generationPrompt,
        config: {
            tools: [{ googleSearch: {} }],
        },
    });

    const listWithLinksText = response.text;
    const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks as Source[] || [];

    if (!listWithLinksText) {
        throw new Error('Could not find product links.');
    }

    // Parse the response text into a structured array
    const links: ShoppingListItem[] = listWithLinksText
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.includes('|'))
        .map(line => {
            const parts = line.split('|');
            const item = parts[0].trim().replace(/^[\*\-]\s*/, ''); // Also remove potential markdown bullets
            const url = parts[1].trim();
            return { item, url };
        })
        .filter(item => item.item && item.url && item.url.includes('amazon.com'));


    return { links, sources };
};
