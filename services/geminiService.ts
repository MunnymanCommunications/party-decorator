import { GoogleGenAI, Modality } from "@google/genai";
import { parseDataUrl } from '../utils/fileUtils';
import type { Source, ShoppingListItem } from '../types';

if (!import.meta.env.VITE_API_KEY) {
    throw new Error("VITE_API_KEY environment variable is not set");
}

const ai = new GoogleGenAI({ apiKey: import.meta.env.VITE_API_KEY });

export const editImage = async (base64Image: string, prompt: string): Promise<string> => {
    const { mimeType, data } = parseDataUrl(base64Image);

    // Add instruction to avoid generating people
    const fullPrompt = `${prompt}. Do not add any people or human figures to the image.`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
            parts: [
                {
                    inlineData: {
                        data,
                        mimeType,
                    },
                },
                {
                    text: fullPrompt,
                },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE],
        },
    });

    const imagePart = response.candidates?.[0]?.content?.parts?.[0];
    if (imagePart?.inlineData) {
        return `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
    }

    throw new Error('No image was generated by the API.');
};


// Step 1: Generate a simple list of items from the image.
export const generateShoppingListItems = async (
    base64OriginalImage: string,
    base64GeneratedImage: string,
): Promise<string> => {
    const originalImageParts = parseDataUrl(base64OriginalImage);
    const generatedImageParts = parseDataUrl(base64GeneratedImage);
    
    const generationPrompt = "Compare the 'before' and 'after' images. Create a simple bulleted list of only the new decoration items that were added to the 'before' image to create the 'after' image. Do not include items that were already present in the original room. Only list the new item names, without descriptions or links.";
    
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: {
            parts: [
                { text: "This is the 'before' image of the room:" },
                {
                    inlineData: {
                        data: originalImageParts.data,
                        mimeType: originalImageParts.mimeType,
                    },
                },
                { text: "This is the 'after' image, with party decorations added:"},
                {
                    inlineData: {
                        data: generatedImageParts.data,
                        mimeType: generatedImageParts.mimeType,
                    },
                },
                {
                    text: generationPrompt,
                }
            ],
        },
    });

    const list = response.text;
    if (!list) {
        throw new Error('Could not generate a shopping list.');
    }

    return list;
};

// Step 2: Generate Amazon search URLs for the items in the list.
export const findProductLinks = async (itemList: string, themePrompt: string): Promise<{ links: ShoppingListItem[]; sources: Source[] }> => {
    const themeContext = themePrompt ? ` The user has specified a theme for the party: "${themePrompt}".` : '';

    const generationPrompt = `For each item in the following shopping list, generate a concise and effective search query string for Amazon.com.
${themeContext} When creating the search query, you MUST incorporate the theme. For example, if the item is "string lights" and the theme is "Rustic Wedding", a good search query would be "rustic wedding string lights".

Format the output as a list where each line contains only the original item name, a pipe character (|), and then the generated search query. Do not include any extra text, titles, or markdown formatting.

SHOPPING LIST:
${itemList}`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: generationPrompt,
    });

    const listWithQueriesText = response.text;
    
    // Sources will be empty since we are not using grounding for this step
    const sources: Source[] = [];

    if (!listWithQueriesText) {
        throw new Error('Could not generate search queries.');
    }

    // Parse the response text and construct Amazon search URLs
    const links: ShoppingListItem[] = listWithQueriesText
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.includes('|'))
        .map(line => {
            const parts = line.split('|');
            const item = parts[0].trim().replace(/^[\*\-]\s*/, ''); // Also remove potential markdown bullets
            const searchQuery = parts[1].trim();
            
            // URL-encode the search query and construct the Amazon URL
            const encodedQuery = encodeURIComponent(searchQuery);
            const url = `https://www.amazon.com/s?k=${encodedQuery}`;
            
            return { item, url };
        })
        .filter(item => item.item && item.url);


    return { links, sources };
};